//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/PgpApi.java
//

#include "ArmoredOutputStream.h"
#include "BCPGOutputStream.h"
#include "BcPBEDataDecryptorFactory.h"
#include "BcPBEKeyEncryptionMethodGenerator.h"
#include "BcPGPContentSignerBuilder.h"
#include "BcPGPContentVerifierBuilderProvider.h"
#include "BcPGPDigestCalculatorProvider.h"
#include "BcPGPObjectFactory.h"
#include "CompressionAlgorithm.h"
#include "DecryptionBuilder.h"
#include "DecryptionBuilderInterface.h"
#include "DecryptionStream.h"
#include "EncryptionBuilder.h"
#include "EncryptionBuilderInterface.h"
#include "EncryptionStream.h"
#include "HashAlgorithmTags.h"
#include "HashAlgorithmUtil.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JcaPGPObjectFactory.h"
#include "JcePGPDataEncryptorBuilder.h"
#include "KeyRingProtectionSettings.h"
#include "KeyRingReader.h"
#include "MissingPublicKeyCallback.h"
#include "NewPGPUtil.h"
#include "PBEKeyEncryptionMethodGenerator.h"
#include "PBESecretKeyDecryptor.h"
#include "PGPCompressedData.h"
#include "PGPCompressedDataGenerator.h"
#include "PGPEncryptedDataGenerator.h"
#include "PGPEncryptedDataList.h"
#include "PGPLiteralData.h"
#include "PGPLiteralDataGenerator.h"
#include "PGPPBEEncryptedData.h"
#include "PGPPrivateKey.h"
#include "PGPPublicKey.h"
#include "PGPPublicKeyRingCollection.h"
#include "PGPSecretKey.h"
#include "PGPSecretKeyRing.h"
#include "PGPSecretKeyRingCollection.h"
#include "PGPSignature.h"
#include "PGPSignatureGenerator.h"
#include "PGPSignatureList.h"
#include "PGPUtil.h"
#include "Passphrase.h"
#include "PasswordBasedSecretKeyRingProtector.h"
#include "PgpApi.h"
#include "PgpError.h"
#include "PgpErrorCase.h"
#include "PgpUtilApi.h"
#include "PublicKeyPacket.h"
#include "SecretKeyPassphraseProvider.h"
#include "Streams.h"
#include "SymmetricKeyAlgorithm.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/PrintStream.h"
#include "java/lang/Long.h"
#include "java/lang/System.h"
#include "java/lang/Throwable.h"
#include "java/security/SecureRandom.h"
#include "java/util/Date.h"

@interface LibComAfterlogicPgpPgpApi () {
 @public
  NSString *PGP_SIGN_TITLE_;
  NSString *BEGIN_SIGNATURE_;
  NSString *END_SIGNATURE_;
}

- (void)compressWithJavaIoInputStream:(JavaIoInputStream *)inputStream
               withJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                              withInt:(jint)algorithm
                             withLong:(jlong)size;

@end

J2OBJC_FIELD_SETTER(LibComAfterlogicPgpPgpApi, PGP_SIGN_TITLE_, NSString *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpPgpApi, BEGIN_SIGNATURE_, NSString *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpPgpApi, END_SIGNATURE_, NSString *)

__attribute__((unused)) static void LibComAfterlogicPgpPgpApi_compressWithJavaIoInputStream_withJavaIoOutputStream_withInt_withLong_(LibComAfterlogicPgpPgpApi *self, JavaIoInputStream *inputStream, JavaIoOutputStream *outputStream, jint algorithm, jlong size);

@interface LibComAfterlogicPgpPgpApi_1 : NSObject < LibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider > {
 @public
  NSString *val$password_;
}

- (instancetype)initWithNSString:(NSString *)capture$0;

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId;

@end

J2OBJC_EMPTY_STATIC_INIT(LibComAfterlogicPgpPgpApi_1)

__attribute__((unused)) static void LibComAfterlogicPgpPgpApi_1_initWithNSString_(LibComAfterlogicPgpPgpApi_1 *self, NSString *capture$0);

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_1 *new_LibComAfterlogicPgpPgpApi_1_initWithNSString_(NSString *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_1 *create_LibComAfterlogicPgpPgpApi_1_initWithNSString_(NSString *capture$0);

@interface LibComAfterlogicPgpPgpApi_2 : NSObject < LibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider > {
 @public
  NSString *val$password_;
}

- (instancetype)initWithNSString:(NSString *)capture$0;

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId;

@end

J2OBJC_EMPTY_STATIC_INIT(LibComAfterlogicPgpPgpApi_2)

__attribute__((unused)) static void LibComAfterlogicPgpPgpApi_2_initWithNSString_(LibComAfterlogicPgpPgpApi_2 *self, NSString *capture$0);

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_2 *new_LibComAfterlogicPgpPgpApi_2_initWithNSString_(NSString *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_2 *create_LibComAfterlogicPgpPgpApi_2_initWithNSString_(NSString *capture$0);

@interface LibComAfterlogicPgpPgpApi_3 : NSObject < LibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback > {
 @public
  LibComAfterlogicPgpPgpApi *this$0_;
}

- (instancetype)initWithLibComAfterlogicPgpPgpApi:(LibComAfterlogicPgpPgpApi *)outer$;

- (LibOrgBouncycastleOpenpgpPGPPublicKey *)onMissingPublicKeyEncounteredWithJavaLangLong:(JavaLangLong *)keyId;

@end

J2OBJC_EMPTY_STATIC_INIT(LibComAfterlogicPgpPgpApi_3)

__attribute__((unused)) static void LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi_3 *self, LibComAfterlogicPgpPgpApi *outer$);

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_3 *new_LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_3 *create_LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi *outer$);

@interface LibComAfterlogicPgpPgpApi_4 : NSObject < LibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider > {
 @public
  NSString *val$password_;
}

- (instancetype)initWithNSString:(NSString *)capture$0;

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId;

@end

J2OBJC_EMPTY_STATIC_INIT(LibComAfterlogicPgpPgpApi_4)

__attribute__((unused)) static void LibComAfterlogicPgpPgpApi_4_initWithNSString_(LibComAfterlogicPgpPgpApi_4 *self, NSString *capture$0);

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_4 *new_LibComAfterlogicPgpPgpApi_4_initWithNSString_(NSString *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static LibComAfterlogicPgpPgpApi_4 *create_LibComAfterlogicPgpPgpApi_4_initWithNSString_(NSString *capture$0);

@implementation LibComAfterlogicPgpPgpApi

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibComAfterlogicPgpPgpApi_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jboolean)getLastVerifyResult {
  return lastVerifyResult_;
}

- (void)encryptWithNSString:(NSString *)privateKey
          withNSStringArray:(IOSObjectArray *)publicKeys
               withNSString:(NSString *)password
      withJavaIoInputStream:(JavaIoInputStream *)inputStream
     withJavaIoOutputStream:(JavaIoOutputStream *)outputStream {
  @try {
    id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_ToRecipients> toRecipients = [new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_init() onOutputStreamWithJavaIoOutputStream:outputStream];
    LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *publicKeyRing = LibComAfterlogicPgpPgpUtilApi_getPublicKeyRingWithNSStringArray_(publicKeys);
    id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith> signWith;
    if ([((LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *) nil_chk(publicKeyRing)) size] > 0) {
      signWith = [((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>) nil_chk(([((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_ToRecipients>) nil_chk(toRecipients)) toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollectionArray:[IOSObjectArray newArrayWithObjects:(id[]){ publicKeyRing } count:1 type:LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection_class_()]]))) usingAlgorithmsWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256) withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, SHA512) withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:JreLoadEnum(LibComAfterlogicPgpAlgorithmCompressionAlgorithm, ZIP)];
    }
    else {
      signWith = [((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>) nil_chk([((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_ToRecipients>) nil_chk(toRecipients)) toRecipients])) usingAlgorithmsWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256) withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, SHA512) withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:JreLoadEnum(LibComAfterlogicPgpAlgorithmCompressionAlgorithm, ZIP)];
    }
    id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor> armor;
    if (privateKey != nil && password != nil) {
      LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings *setting = new_LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_initWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withInt_(JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256), JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, MD5), 0);
      LibOrgBouncycastleOpenpgpPGPSecretKeyRing *secretKeysRing = [new_LibComAfterlogicPgpKeyParsingKeyRingReader_init() secretKeyRingWithNSString:privateKey];
      LibOrgBouncycastleOpenpgpPGPSecretKey *secretKey = nil;
      for (LibOrgBouncycastleOpenpgpPGPSecretKey * __strong key in nil_chk(secretKeysRing)) {
        if (secretKey == nil || [((LibOrgBouncycastleOpenpgpPGPSecretKey *) nil_chk(key)) isMasterKey]) {
          secretKey = key;
        }
      }
      LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector *secretKeyRingProtector = new_LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector_initWithLibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_withLibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider_(setting, new_LibComAfterlogicPgpPgpApi_1_initWithNSString_(password));
      armor = [((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith>) nil_chk(signWith)) signWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:secretKeyRingProtector withLibOrgBouncycastleOpenpgpPGPSecretKeyArray:[IOSObjectArray newArrayWithObjects:(id[]){ secretKey } count:1 type:LibOrgBouncycastleOpenpgpPGPSecretKey_class_()]];
    }
    else {
      armor = [((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith>) nil_chk(signWith)) doNotSign];
    }
    JavaIoOutputStream *encryptionStream = [((id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor>) nil_chk(armor)) asciiArmor];
    IOSByteArray *bs = [IOSByteArray newArrayWithLength:4096];
    jint numRead;
    while ((numRead = [((JavaIoInputStream *) nil_chk(inputStream)) readWithByteArray:bs withInt:0 withInt:bs->size_]) >= 0) {
      [((JavaIoOutputStream *) nil_chk(encryptionStream)) writeWithByteArray:bs withInt:0 withInt:numRead];
    }
    [((JavaIoOutputStream *) nil_chk(encryptionStream)) close];
    [inputStream close];
    [((JavaIoOutputStream *) nil_chk(outputStream)) close];
  }
  @catch (JavaLangThrowable *e) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("$@", @"PgpApi.encrypt error:", e)];
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

- (void)decryptWithNSString:(NSString *)privateKey
          withNSStringArray:(IOSObjectArray *)publicKeys
               withNSString:(NSString *)password
      withJavaIoInputStream:(JavaIoInputStream *)inputStream
     withJavaIoOutputStream:(JavaIoOutputStream *)outputStream {
  @try {
    lastVerifyResult_ = true;
    id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_DecryptWith> decryptWith = [new_LibComAfterlogicPgpDecryption_verificationDecryptionBuilder_init() onInputStreamWithJavaIoInputStream:inputStream];
    LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings *setting = new_LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_initWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withInt_(JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256), JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, MD5), 0);
    LibOrgBouncycastleOpenpgpPGPSecretKeyRing *secretKeys = [new_LibComAfterlogicPgpKeyParsingKeyRingReader_init() secretKeyRingWithNSString:privateKey];
    LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector *secretKeyRingProtector = new_LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector_initWithLibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_withLibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider_(setting, new_LibComAfterlogicPgpPgpApi_2_initWithNSString_(password));
    LibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection *secretKeyRings = LibComAfterlogicPgpUtilNewPGPUtil_keyRingsToKeyRingCollectionWithLibOrgBouncycastleOpenpgpPGPSecretKeyRingArray_([IOSObjectArray newArrayWithObjects:(id[]){ secretKeys } count:1 type:LibOrgBouncycastleOpenpgpPGPSecretKeyRing_class_()]);
    id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_VerifyWith> verifyWith = [((id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_DecryptWith>) nil_chk(decryptWith)) decryptWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:secretKeyRingProtector withLibOrgBouncycastleOpenpgpPGPSecretKeyRingCollection:secretKeyRings];
    id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_Build> build;
    build = [((id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_HandleMissingPublicKeys>) nil_chk([((id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_VerifyWith>) nil_chk(verifyWith)) verifyWithWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection:LibComAfterlogicPgpPgpUtilApi_getPublicKeyRingWithNSStringArray_(publicKeys)])) handleMissingPublicKeysWithWithLibComAfterlogicPgpDecryption_verificationMissingPublicKeyCallback:new_LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(self)];
    JavaIoInputStream *decryptionStream = [((id<LibComAfterlogicPgpDecryption_verificationDecryptionBuilderInterface_Build>) nil_chk(build)) build];
    LibOrgBouncycastleUtilIoStreams_pipeAllWithJavaIoInputStream_withJavaIoOutputStream_(decryptionStream, outputStream);
    [((JavaIoInputStream *) nil_chk(decryptionStream)) close];
    [((JavaIoInputStream *) nil_chk(inputStream)) close];
    [((JavaIoOutputStream *) nil_chk(outputStream)) close];
  }
  @catch (JavaLangThrowable *e) {
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

- (NSString *)signWithNSString:(NSString *)text
                  withNSString:(NSString *)privateKey
                  withNSString:(NSString *)password {
  @try {
    JavaIoByteArrayOutputStream *output = new_JavaIoByteArrayOutputStream_init();
    JavaIoInputStream *input = new_JavaIoByteArrayInputStream_initWithByteArray_([((NSString *) nil_chk(text)) java_getBytes]);
    LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings *setting = new_LibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_initWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withInt_(JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256), JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, MD5), 0);
    LibOrgBouncycastleOpenpgpPGPSecretKeyRing *secretKeysRing = [new_LibComAfterlogicPgpKeyParsingKeyRingReader_init() secretKeyRingWithNSString:privateKey];
    LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector *secretKeyRingProtector = new_LibComAfterlogicPgpKeyProtectionPasswordBasedSecretKeyRingProtector_initWithLibComAfterlogicPgpKeyProtectionKeyRingProtectionSettings_withLibComAfterlogicPgpKeyProtectionSecretKeyPassphraseProvider_(setting, new_LibComAfterlogicPgpPgpApi_4_initWithNSString_(password));
    LibOrgBouncycastleOpenpgpPGPSecretKey *secretKey = nil;
    for (LibOrgBouncycastleOpenpgpPGPSecretKey * __strong key in nil_chk(secretKeysRing)) {
      if (secretKey == nil || [((LibOrgBouncycastleOpenpgpPGPSecretKey *) nil_chk(key)) isMasterKey]) {
        secretKey = key;
      }
    }
    LibOrgBouncycastleOpenpgpPGPPrivateKey *pgpPrivateKey = [((LibOrgBouncycastleOpenpgpPGPSecretKey *) nil_chk(secretKey)) extractPrivateKeyWithLibOrgBouncycastleOpenpgpOperatorPBESecretKeyDecryptor:[secretKeyRingProtector getDecryptorWithJavaLangLong:JavaLangLong_valueOfWithLong_([secretKey getKeyID])]];
    LibOrgBouncycastleOpenpgpPGPSignatureGenerator *signatureGenerator = new_LibOrgBouncycastleOpenpgpPGPSignatureGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPContentSignerBuilder_(new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPContentSignerBuilder_initWithInt_withInt_([((LibOrgBouncycastleBcpgPublicKeyPacket *) nil_chk([((LibOrgBouncycastleOpenpgpPGPPrivateKey *) nil_chk(pgpPrivateKey)) getPublicKeyPacket])) getAlgorithm], LibOrgBouncycastleBcpgHashAlgorithmTags_SHA512));
    [signatureGenerator init__WithInt:LibOrgBouncycastleOpenpgpPGPSignature_CANONICAL_TEXT_DOCUMENT withLibOrgBouncycastleOpenpgpPGPPrivateKey:pgpPrivateKey];
    JavaIoOutputStream *armor = new_LibOrgBouncycastleBcpgArmoredOutputStream_initWithJavaIoOutputStream_(output);
    JavaIoOutputStream *stream = new_LibOrgBouncycastleBcpgBCPGOutputStream_initWithJavaIoOutputStream_(armor);
    IOSByteArray *buff = [IOSByteArray newArrayWithLength:1024];
    jint read;
    while ((read = [input readWithByteArray:buff]) != -1) {
      [signatureGenerator updateWithByteArray:buff withInt:0 withInt:read];
    }
    LibOrgBouncycastleOpenpgpPGPSignature *pgpSignature = [signatureGenerator generate];
    [((LibOrgBouncycastleOpenpgpPGPSignature *) nil_chk(pgpSignature)) encodeWithJavaIoOutputStream:stream];
    [armor close];
    [stream close];
    [output close];
    [input close];
    NSString *signature = [NSString java_stringWithBytes:[output toByteArray]];
    return JreStrcat("$$$$$", PGP_SIGN_TITLE_, @"\x0d\nHash: SHA512\x0d\n\x0d\n", text, @"\x0d\n", signature);
  }
  @catch (JavaLangThrowable *e) {
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

- (NSString *)verifyWithNSString:(NSString *)text
               withNSStringArray:(IOSObjectArray *)publicKeys {
  @try {
    lastVerifyResult_ = false;
    jint startMessageIndex = [((NSString *) nil_chk(text)) java_indexOfString:PGP_SIGN_TITLE_];
    if (startMessageIndex < 0) {
      return text;
    }
    startMessageIndex = [text java_indexOfString:@"\n" fromIndex:startMessageIndex + [((NSString *) nil_chk(PGP_SIGN_TITLE_)) java_length]] + 1;
    startMessageIndex = [text java_indexOfString:@"\n" fromIndex:startMessageIndex] + 1;
    startMessageIndex = [text java_indexOfString:@"\n" fromIndex:startMessageIndex] + 1;
    jint startSignature = [text java_indexOfString:BEGIN_SIGNATURE_ fromIndex:startMessageIndex];
    if (startSignature < 0) {
      return text;
    }
    NSString *message = [text java_substring:startMessageIndex endIndex:startSignature];
    jint endMessageIndex = [((NSString *) nil_chk(message)) java_lastIndexOfString:@"\n"];
    if ([message charAtWithInt:endMessageIndex - 1] == 0x000d) {
      endMessageIndex = endMessageIndex - 1;
    }
    endMessageIndex += startMessageIndex;
    jint endSignature = [text java_indexOfString:END_SIGNATURE_];
    if (endSignature < 0) {
      return text;
    }
    endSignature += [((NSString *) nil_chk(END_SIGNATURE_)) java_length];
    message = [text java_substring:startMessageIndex endIndex:endMessageIndex];
    JavaIoByteArrayInputStream *signedDataStream = new_JavaIoByteArrayInputStream_initWithByteArray_([((NSString *) nil_chk(message)) java_getBytes]);
    JavaIoByteArrayInputStream *signature = new_JavaIoByteArrayInputStream_initWithByteArray_([((NSString *) nil_chk([text java_substring:startSignature endIndex:endSignature])) java_getBytes]);
    @try {
      JavaIoInputStream *decoderStream = LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(signature);
      LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *pgpPublicKeyRingCollection = LibComAfterlogicPgpPgpUtilApi_getPublicKeyRingWithNSStringArray_(publicKeys);
      LibOrgBouncycastleOpenpgpJcajceJcaPGPObjectFactory *pgpFact = new_LibOrgBouncycastleOpenpgpJcajceJcaPGPObjectFactory_initWithJavaIoInputStream_(decoderStream);
      LibOrgBouncycastleOpenpgpPGPSignatureList *signatureList = ((LibOrgBouncycastleOpenpgpPGPSignatureList *) cast_chk([pgpFact nextObject], [LibOrgBouncycastleOpenpgpPGPSignatureList class]));
      LibOrgBouncycastleOpenpgpPGPSignature *pgpSignature = nil;
      for (LibOrgBouncycastleOpenpgpPGPSignature * __strong item in nil_chk(signatureList)) {
        if ([((LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *) nil_chk(pgpPublicKeyRingCollection)) containsWithLong:[((LibOrgBouncycastleOpenpgpPGPSignature *) nil_chk(item)) getKeyID]]) {
          pgpSignature = item;
          break;
        }
      }
      if (pgpSignature == nil) {
        return message;
      }
      LibOrgBouncycastleOpenpgpPGPPublicKey *key = [((LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *) nil_chk(pgpPublicKeyRingCollection)) getPublicKeyWithLong:[pgpSignature getKeyID]];
      [pgpSignature init__WithLibOrgBouncycastleOpenpgpOperatorPGPContentVerifierBuilderProvider:new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPContentVerifierBuilderProvider_init() withLibOrgBouncycastleOpenpgpPGPPublicKey:key];
      IOSByteArray *buff = [IOSByteArray newArrayWithLength:1024];
      jint read;
      while ((read = [signedDataStream readWithByteArray:buff]) != -1) {
        [pgpSignature updateWithByteArray:buff withInt:0 withInt:read];
      }
      [signedDataStream close];
      lastVerifyResult_ = [pgpSignature verify];
    }
    @catch (JavaLangThrowable *e) {
      [e printStackTrace];
    }
    return message;
  }
  @catch (JavaLangThrowable *e) {
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

- (void)symmetricallyEncryptWithJavaIoInputStream:(JavaIoInputStream *)inputStream
                           withJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                                   withJavaIoFile:(JavaIoFile *)prepareEncrypt
                                 withJavaLangLong:(JavaLangLong *)length
                                     withNSString:(NSString *)password {
  @try {
    LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *encryptionAlgorithm = JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256);
    LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm = JreLoadEnum(LibComAfterlogicPgpAlgorithmCompressionAlgorithm, ZIP);
    JavaIoOutputStream *armorOut = new_LibOrgBouncycastleBcpgArmoredOutputStream_initWithJavaIoOutputStream_(outputStream);
    LibComAfterlogicPgpUtilPassphrase *passphrase = new_LibComAfterlogicPgpUtilPassphrase_initWithCharArray_([((NSString *) nil_chk(password)) java_toCharArray]);
    LibComAfterlogicPgpPgpApi_compressWithJavaIoInputStream_withJavaIoOutputStream_withInt_withLong_(self, inputStream, new_JavaIoFileOutputStream_initWithJavaIoFile_(prepareEncrypt), [((LibComAfterlogicPgpAlgorithmCompressionAlgorithm *) nil_chk(compressionAlgorithm)) getAlgorithmId], [((JavaLangLong *) nil_chk(length)) longLongValue]);
    JavaIoInputStream *preparedInputStream = new_JavaIoFileInputStream_initWithJavaIoFile_(prepareEncrypt);
    LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator *encGen = new_LibOrgBouncycastleOpenpgpPGPEncryptedDataGenerator_initWithLibOrgBouncycastleOpenpgpOperatorPGPDataEncryptorBuilder_([((LibOrgBouncycastleOpenpgpOperatorJcajceJcePGPDataEncryptorBuilder *) nil_chk([new_LibOrgBouncycastleOpenpgpOperatorJcajceJcePGPDataEncryptorBuilder_initWithInt_([((LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *) nil_chk(encryptionAlgorithm)) getAlgorithmId]) setWithIntegrityPacketWithBoolean:true])) setSecureRandomWithJavaSecuritySecureRandom:new_JavaSecuritySecureRandom_init()]);
    [encGen addMethodWithLibOrgBouncycastleOpenpgpOperatorPGPKeyEncryptionMethodGenerator:[new_LibOrgBouncycastleOpenpgpOperatorBcBcPBEKeyEncryptionMethodGenerator_initWithCharArray_([passphrase getChars]) setSecureRandomWithJavaSecuritySecureRandom:new_JavaSecuritySecureRandom_init()]];
    JavaIoOutputStream *encOut = [encGen openWithJavaIoOutputStream:armorOut withLong:[((JavaIoFile *) nil_chk(prepareEncrypt)) length]];
    LibOrgBouncycastleUtilIoStreams_pipeAllWithJavaIoInputStream_withJavaIoOutputStream_(preparedInputStream, encOut);
    [((JavaIoOutputStream *) nil_chk(encOut)) close];
    [prepareEncrypt delete__];
    [encOut close];
    [preparedInputStream close];
    [((JavaIoInputStream *) nil_chk(inputStream)) close];
    [armorOut close];
    [((JavaIoOutputStream *) nil_chk(outputStream)) close];
  }
  @catch (JavaLangThrowable *e) {
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

- (void)compressWithJavaIoInputStream:(JavaIoInputStream *)inputStream
               withJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                              withInt:(jint)algorithm
                             withLong:(jlong)size {
  LibComAfterlogicPgpPgpApi_compressWithJavaIoInputStream_withJavaIoOutputStream_withInt_withLong_(self, inputStream, outputStream, algorithm, size);
}

- (void)symmetricallyDecryptWithJavaIoInputStream:(JavaIoInputStream *)inputStream
                           withJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                                     withNSString:(NSString *)password {
  @try {
    lastVerifyResult_ = false;
    LibComAfterlogicPgpUtilPassphrase *passphrase = new_LibComAfterlogicPgpUtilPassphrase_initWithCharArray_([((NSString *) nil_chk(password)) java_toCharArray]);
    LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *pbe;
    JavaIoInputStream *decoderInput = LibOrgBouncycastleOpenpgpPGPUtil_getDecoderStreamWithJavaIoInputStream_(inputStream);
    LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory *pgpF = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_(decoderInput);
    LibOrgBouncycastleOpenpgpPGPEncryptedDataList *enc;
    id o = [pgpF nextObject];
    if ([o isKindOfClass:[LibOrgBouncycastleOpenpgpPGPEncryptedDataList class]]) {
      enc = (LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) o;
    }
    else {
      enc = (LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) cast_chk([pgpF nextObject], [LibOrgBouncycastleOpenpgpPGPEncryptedDataList class]);
    }
    pbe = (LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *) cast_chk([((LibOrgBouncycastleOpenpgpPGPEncryptedDataList *) nil_chk(enc)) getWithInt:0], [LibOrgBouncycastleOpenpgpPGPPBEEncryptedData class]);
    JavaIoInputStream *clear = [((LibOrgBouncycastleOpenpgpPGPPBEEncryptedData *) nil_chk(pbe)) getDataStreamWithLibOrgBouncycastleOpenpgpOperatorPBEDataDecryptorFactory:new_LibOrgBouncycastleOpenpgpOperatorBcBcPBEDataDecryptorFactory_initWithCharArray_withLibOrgBouncycastleOpenpgpOperatorBcBcPGPDigestCalculatorProvider_([passphrase getChars], digestCalculator_)];
    LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory *pgpFact = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_(clear);
    o = [pgpFact nextObject];
    if ([o isKindOfClass:[LibOrgBouncycastleOpenpgpPGPCompressedData class]]) {
      pgpFact = new_LibOrgBouncycastleOpenpgpBcBcPGPObjectFactory_initWithJavaIoInputStream_([((LibOrgBouncycastleOpenpgpPGPCompressedData *) nil_chk(((LibOrgBouncycastleOpenpgpPGPCompressedData *) o))) getDataStream]);
      o = [pgpFact nextObject];
    }
    LibOrgBouncycastleOpenpgpPGPLiteralData *ld = (LibOrgBouncycastleOpenpgpPGPLiteralData *) cast_chk(o, [LibOrgBouncycastleOpenpgpPGPLiteralData class]);
    JavaIoInputStream *unc = [((LibOrgBouncycastleOpenpgpPGPLiteralData *) nil_chk(ld)) getInputStream];
    LibOrgBouncycastleUtilIoStreams_pipeAllWithJavaIoInputStream_withJavaIoOutputStream_(unc, outputStream);
    [((JavaIoOutputStream *) nil_chk(outputStream)) close];
    [((JavaIoInputStream *) nil_chk(decoderInput)) close];
    lastVerifyResult_ = [pbe verify];
  }
  @catch (JavaLangThrowable *e) {
    if ([e isKindOfClass:[LibComAfterlogicPgpPgpError class]]) {
      @throw (LibComAfterlogicPgpPgpError *) e;
    }
    else {
      @throw new_LibComAfterlogicPgpPgpError_initWithLibComAfterlogicPgpPgpErrorCase_(JreLoadEnum(LibComAfterlogicPgpPgpErrorCase, Undefined));
    }
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 1, 2, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 7, 8, 6, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, 6, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, 13, -1, -1, -1 },
    { NULL, "V", 0x1, 14, 15, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(getLastVerifyResult);
  methods[2].selector = @selector(encryptWithNSString:withNSStringArray:withNSString:withJavaIoInputStream:withJavaIoOutputStream:);
  methods[3].selector = @selector(decryptWithNSString:withNSStringArray:withNSString:withJavaIoInputStream:withJavaIoOutputStream:);
  methods[4].selector = @selector(signWithNSString:withNSString:withNSString:);
  methods[5].selector = @selector(verifyWithNSString:withNSStringArray:);
  methods[6].selector = @selector(symmetricallyEncryptWithJavaIoInputStream:withJavaIoOutputStream:withJavaIoFile:withJavaLangLong:withNSString:);
  methods[7].selector = @selector(compressWithJavaIoInputStream:withJavaIoOutputStream:withInt:withLong:);
  methods[8].selector = @selector(symmetricallyDecryptWithJavaIoInputStream:withJavaIoOutputStream:withNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "lastVerifyResult_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "digestCalculator_", "LLibOrgBouncycastleOpenpgpOperatorBcBcPGPDigestCalculatorProvider;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "PGP_SIGN_TITLE_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "BEGIN_SIGNATURE_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "END_SIGNATURE_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "encrypt", "LNSString;[LNSString;LNSString;LJavaIoInputStream;LJavaIoOutputStream;", "LJavaIoIOException;LLibOrgBouncycastleOpenpgpPGPException;LLibComAfterlogicPgpPgpError;", "decrypt", "sign", "LNSString;LNSString;LNSString;", "LLibComAfterlogicPgpPgpError;", "verify", "LNSString;[LNSString;", "symmetricallyEncrypt", "LJavaIoInputStream;LJavaIoOutputStream;LJavaIoFile;LJavaLangLong;LNSString;", "compress", "LJavaIoInputStream;LJavaIoOutputStream;IJ", "LJavaIoIOException;", "symmetricallyDecrypt", "LJavaIoInputStream;LJavaIoOutputStream;LNSString;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpPgpApi = { "PgpApi", "lib.com.afterlogic.pgp", ptrTable, methods, fields, 7, 0x1, 9, 5, -1, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpPgpApi;
}

@end

void LibComAfterlogicPgpPgpApi_init(LibComAfterlogicPgpPgpApi *self) {
  NSObject_init(self);
  self->lastVerifyResult_ = true;
  self->digestCalculator_ = new_LibOrgBouncycastleOpenpgpOperatorBcBcPGPDigestCalculatorProvider_init();
  self->PGP_SIGN_TITLE_ = @"-----BEGIN PGP SIGNED MESSAGE-----";
  self->BEGIN_SIGNATURE_ = @"-----BEGIN PGP SIGNATURE-----";
  self->END_SIGNATURE_ = @"-----END PGP SIGNATURE-----";
}

LibComAfterlogicPgpPgpApi *new_LibComAfterlogicPgpPgpApi_init() {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpPgpApi, init)
}

LibComAfterlogicPgpPgpApi *create_LibComAfterlogicPgpPgpApi_init() {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpPgpApi, init)
}

void LibComAfterlogicPgpPgpApi_compressWithJavaIoInputStream_withJavaIoOutputStream_withInt_withLong_(LibComAfterlogicPgpPgpApi *self, JavaIoInputStream *inputStream, JavaIoOutputStream *outputStream, jint algorithm, jlong size) {
  LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator *comData = new_LibOrgBouncycastleOpenpgpPGPCompressedDataGenerator_initWithInt_(algorithm);
  JavaIoOutputStream *cos = [comData openWithJavaIoOutputStream:outputStream];
  LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator *lData = new_LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator_init();
  JavaIoOutputStream *pOut = [lData openWithJavaIoOutputStream:cos withChar:LibOrgBouncycastleOpenpgpPGPLiteralData_BINARY withNSString:LibOrgBouncycastleOpenpgpPGPLiteralDataGenerator_CONSOLE withLong:size withJavaUtilDate:new_JavaUtilDate_init()];
  LibOrgBouncycastleUtilIoStreams_pipeAllWithJavaIoInputStream_withJavaIoOutputStream_(inputStream, pOut);
  [((JavaIoOutputStream *) nil_chk(pOut)) close];
  [comData close];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpPgpApi)

@implementation LibComAfterlogicPgpPgpApi_1

- (instancetype)initWithNSString:(NSString *)capture$0 {
  LibComAfterlogicPgpPgpApi_1_initWithNSString_(self, capture$0);
  return self;
}

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId {
  return new_LibComAfterlogicPgpUtilPassphrase_initWithCharArray_([((NSString *) nil_chk(val$password_)) java_toCharArray]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpUtilPassphrase;", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(getPassphraseForWithJavaLangLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$password_", "LNSString;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getPassphraseFor", "LJavaLangLong;", "LLibComAfterlogicPgpPgpApi;", "encryptWithNSString:withNSStringArray:withNSString:withJavaIoInputStream:withJavaIoOutputStream:" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpPgpApi_1 = { "", "lib.com.afterlogic.pgp", ptrTable, methods, fields, 7, 0x8010, 2, 1, 2, -1, 3, -1, -1 };
  return &_LibComAfterlogicPgpPgpApi_1;
}

@end

void LibComAfterlogicPgpPgpApi_1_initWithNSString_(LibComAfterlogicPgpPgpApi_1 *self, NSString *capture$0) {
  self->val$password_ = capture$0;
  NSObject_init(self);
}

LibComAfterlogicPgpPgpApi_1 *new_LibComAfterlogicPgpPgpApi_1_initWithNSString_(NSString *capture$0) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpPgpApi_1, initWithNSString_, capture$0)
}

LibComAfterlogicPgpPgpApi_1 *create_LibComAfterlogicPgpPgpApi_1_initWithNSString_(NSString *capture$0) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpPgpApi_1, initWithNSString_, capture$0)
}

@implementation LibComAfterlogicPgpPgpApi_2

- (instancetype)initWithNSString:(NSString *)capture$0 {
  LibComAfterlogicPgpPgpApi_2_initWithNSString_(self, capture$0);
  return self;
}

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId {
  return new_LibComAfterlogicPgpUtilPassphrase_initWithCharArray_([((NSString *) nil_chk(val$password_)) java_toCharArray]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpUtilPassphrase;", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(getPassphraseForWithJavaLangLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$password_", "LNSString;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getPassphraseFor", "LJavaLangLong;", "LLibComAfterlogicPgpPgpApi;", "decryptWithNSString:withNSStringArray:withNSString:withJavaIoInputStream:withJavaIoOutputStream:" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpPgpApi_2 = { "", "lib.com.afterlogic.pgp", ptrTable, methods, fields, 7, 0x8010, 2, 1, 2, -1, 3, -1, -1 };
  return &_LibComAfterlogicPgpPgpApi_2;
}

@end

void LibComAfterlogicPgpPgpApi_2_initWithNSString_(LibComAfterlogicPgpPgpApi_2 *self, NSString *capture$0) {
  self->val$password_ = capture$0;
  NSObject_init(self);
}

LibComAfterlogicPgpPgpApi_2 *new_LibComAfterlogicPgpPgpApi_2_initWithNSString_(NSString *capture$0) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpPgpApi_2, initWithNSString_, capture$0)
}

LibComAfterlogicPgpPgpApi_2 *create_LibComAfterlogicPgpPgpApi_2_initWithNSString_(NSString *capture$0) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpPgpApi_2, initWithNSString_, capture$0)
}

@implementation LibComAfterlogicPgpPgpApi_3

- (instancetype)initWithLibComAfterlogicPgpPgpApi:(LibComAfterlogicPgpPgpApi *)outer$ {
  LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(self, outer$);
  return self;
}

- (LibOrgBouncycastleOpenpgpPGPPublicKey *)onMissingPublicKeyEncounteredWithJavaLangLong:(JavaLangLong *)keyId {
  this$0_->lastVerifyResult_ = false;
  return nil;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibOrgBouncycastleOpenpgpPGPPublicKey;", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibComAfterlogicPgpPgpApi:);
  methods[1].selector = @selector(onMissingPublicKeyEncounteredWithJavaLangLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibComAfterlogicPgpPgpApi;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "onMissingPublicKeyEncountered", "LJavaLangLong;", "LLibComAfterlogicPgpPgpApi;", "decryptWithNSString:withNSStringArray:withNSString:withJavaIoInputStream:withJavaIoOutputStream:" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpPgpApi_3 = { "", "lib.com.afterlogic.pgp", ptrTable, methods, fields, 7, 0x8010, 2, 1, 2, -1, 3, -1, -1 };
  return &_LibComAfterlogicPgpPgpApi_3;
}

@end

void LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi_3 *self, LibComAfterlogicPgpPgpApi *outer$) {
  self->this$0_ = outer$;
  NSObject_init(self);
}

LibComAfterlogicPgpPgpApi_3 *new_LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi *outer$) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpPgpApi_3, initWithLibComAfterlogicPgpPgpApi_, outer$)
}

LibComAfterlogicPgpPgpApi_3 *create_LibComAfterlogicPgpPgpApi_3_initWithLibComAfterlogicPgpPgpApi_(LibComAfterlogicPgpPgpApi *outer$) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpPgpApi_3, initWithLibComAfterlogicPgpPgpApi_, outer$)
}

@implementation LibComAfterlogicPgpPgpApi_4

- (instancetype)initWithNSString:(NSString *)capture$0 {
  LibComAfterlogicPgpPgpApi_4_initWithNSString_(self, capture$0);
  return self;
}

- (LibComAfterlogicPgpUtilPassphrase *)getPassphraseForWithJavaLangLong:(JavaLangLong *)keyId {
  return new_LibComAfterlogicPgpUtilPassphrase_initWithCharArray_([((NSString *) nil_chk(val$password_)) java_toCharArray]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpUtilPassphrase;", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(getPassphraseForWithJavaLangLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$password_", "LNSString;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "getPassphraseFor", "LJavaLangLong;", "LLibComAfterlogicPgpPgpApi;", "signWithNSString:withNSString:withNSString:" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpPgpApi_4 = { "", "lib.com.afterlogic.pgp", ptrTable, methods, fields, 7, 0x8010, 2, 1, 2, -1, 3, -1, -1 };
  return &_LibComAfterlogicPgpPgpApi_4;
}

@end

void LibComAfterlogicPgpPgpApi_4_initWithNSString_(LibComAfterlogicPgpPgpApi_4 *self, NSString *capture$0) {
  self->val$password_ = capture$0;
  NSObject_init(self);
}

LibComAfterlogicPgpPgpApi_4 *new_LibComAfterlogicPgpPgpApi_4_initWithNSString_(NSString *capture$0) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpPgpApi_4, initWithNSString_, capture$0)
}

LibComAfterlogicPgpPgpApi_4 *create_LibComAfterlogicPgpPgpApi_4_initWithNSString_(NSString *capture$0) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpPgpApi_4, initWithNSString_, capture$0)
}
