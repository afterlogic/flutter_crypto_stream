//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../android/src/main/kotlin/lib/com/afterlogic/pgp/encryption_signing/EncryptionBuilder.java
//

#include "And.h"
#include "CompressionAlgorithm.h"
#include "EncryptionBuilder.h"
#include "EncryptionBuilderInterface.h"
#include "EncryptionKeySelectionStrategy.h"
#include "EncryptionStream.h"
#include "HashAlgorithmUtil.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "MultiMap.h"
#include "NoRevocation.h"
#include "PBESecretKeyDecryptor.h"
#include "PGPPrivateKey.h"
#include "PGPPublicKey.h"
#include "PGPPublicKeyRing.h"
#include "PGPPublicKeyRingCollection.h"
#include "PGPSecretKey.h"
#include "PGPSecretKeyRing.h"
#include "PublicKeyRingSelectionStrategy.h"
#include "PublicKeySelectionStrategy.h"
#include "SecretKeyRingProtector.h"
#include "SecretKeyRingSelectionStrategy.h"
#include "SecretKeySelectionStrategy.h"
#include "SignatureKeySelectionStrategy.h"
#include "SymmetricKeyAlgorithm.h"
#include "java/io/OutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Long.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"

@interface LibComAfterlogicPgpEncryption_signingEncryptionBuilder () {
 @public
  JavaIoOutputStream *outputStream_;
  id<JavaUtilSet> encryptionKeys_;
  id<JavaUtilSet> signingKeys_;
  id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector> signingKeysDecryptor_;
  LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *symmetricKeyAlgorithm_;
  LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *hashAlgorithmUtil_;
  LibComAfterlogicPgpAlgorithmCompressionAlgorithm *compressionAlgorithm_;
  jboolean asciiArmor_;
}

@end

J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, outputStream_, JavaIoOutputStream *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, encryptionKeys_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, signingKeys_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, signingKeysDecryptor_, id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, symmetricKeyAlgorithm_, LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, hashAlgorithmUtil_, LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *)
J2OBJC_FIELD_SETTER(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, compressionAlgorithm_, LibComAfterlogicPgpAlgorithmCompressionAlgorithm *)

@interface LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl () {
 @public
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder *this$0_;
}

@end

@interface LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl () {
 @public
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder *this$0_;
}

@end

@interface LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl () {
 @public
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder *this$0_;
}

@end

@interface LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl () {
 @public
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder *this$0_;
}

- (LibComAfterlogicPgpEncryption_signingEncryptionStream *)build;

@end

__attribute__((unused)) static LibComAfterlogicPgpEncryption_signingEncryptionStream *LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_build(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl *self);

@implementation LibComAfterlogicPgpEncryption_signingEncryptionBuilder

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_ToRecipients>)onOutputStreamWithJavaIoOutputStream:(JavaIoOutputStream *)outputStream {
  self->outputStream_ = outputStream;
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(self);
}

- (LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *)encryptionKeySelector {
  return new_LibComAfterlogicPgpKeySelectionKeyUtilAnd_PubKeySelectionStrategy_initWithLibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy_withLibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy_(new_LibComAfterlogicPgpKeySelectionKeyImplNoRevocation_PubKeySelectionStrategy_init(), new_LibComAfterlogicPgpKeySelectionKeyImplEncryptionKeySelectionStrategy_init());
}

- (LibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy *)signingKeySelector {
  return new_LibComAfterlogicPgpKeySelectionKeyUtilAnd_SecKeySelectionStrategy_initWithLibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy_withLibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy_(new_LibComAfterlogicPgpKeySelectionKeyImplNoRevocation_SecKeySelectionStrategy_init(), new_LibComAfterlogicPgpKeySelectionKeyImplSignatureKeySelectionStrategy_init());
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_ToRecipients;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy;", 0x0, -1, -1, -1, 2, -1, -1 },
    { NULL, "LLibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy;", 0x0, -1, -1, -1, 3, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(onOutputStreamWithJavaIoOutputStream:);
  methods[2].selector = @selector(encryptionKeySelector);
  methods[3].selector = @selector(signingKeySelector);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "outputStream_", "LJavaIoOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "encryptionKeys_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x12, -1, -1, 4, -1 },
    { "signingKeys_", "LJavaUtilSet;", .constantValue.asLong = 0, 0x12, -1, -1, 5, -1 },
    { "signingKeysDecryptor_", "LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "symmetricKeyAlgorithm_", "LLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "hashAlgorithmUtil_", "LLibComAfterlogicPgpAlgorithmHashAlgorithmUtil;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "compressionAlgorithm_", "LLibComAfterlogicPgpAlgorithmCompressionAlgorithm;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "asciiArmor_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "onOutputStream", "LJavaIoOutputStream;", "<O:Ljava/lang/Object;>()Llib/com/afterlogic/pgp/key/selection/key/PublicKeySelectionStrategy<TO;>;", "<O:Ljava/lang/Object;>()Llib/com/afterlogic/pgp/key/selection/key/SecretKeySelectionStrategy<TO;>;", "Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPPublicKey;>;", "Ljava/util/Set<Llib/org/bouncycastle/openpgp/PGPSecretKey;>;", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl;LLibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl;LLibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl;LLibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionBuilder = { "EncryptionBuilder", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x1, 4, 8, -1, 6, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionBuilder;
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionBuilder_init(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *self) {
  NSObject_init(self);
  self->encryptionKeys_ = new_JavaUtilHashSet_init();
  self->signingKeys_ = new_JavaUtilHashSet_init();
  self->symmetricKeyAlgorithm_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_128);
  self->hashAlgorithmUtil_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, SHA256);
  self->compressionAlgorithm_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmCompressionAlgorithm, UNCOMPRESSED);
  self->asciiArmor_ = false;
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder *new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_init() {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, init)
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder *create_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_init() {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionBuilder)

@implementation LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl

- (instancetype)initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *)outer$ {
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(self, outer$);
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)toRecipients {
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyArray:(IOSObjectArray *)keys {
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPPublicKey * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    LibOrgBouncycastleOpenpgpPGPPublicKey * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPPublicKey *k = *b__++;
      if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:k]) {
        [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:k];
      }
      else {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J$", @"Key ", [((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(k)) getKeyID], @" is not a valid encryption key."));
      }
    }
  }
  if ([((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) isEmpty]) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"No valid encryption keys found!");
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingArray:(IOSObjectArray *)keys {
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRing * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRing * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPPublicKeyRing *ring = *b__++;
      for (LibOrgBouncycastleOpenpgpPGPPublicKey * __strong k in nil_chk(ring)) {
        if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:k]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:k];
        }
      }
    }
  }
  if ([((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) isEmpty]) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"No valid encryption keys found!");
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollectionArray:(IOSObjectArray *)keys {
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *collection = *b__++;
      for (LibOrgBouncycastleOpenpgpPGPPublicKeyRing * __strong ring in nil_chk(collection)) {
        for (LibOrgBouncycastleOpenpgpPGPPublicKey * __strong k in nil_chk(ring)) {
          if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:k]) {
            [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:k];
          }
        }
      }
    }
  }
  if ([((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) isEmpty]) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"No valid encryption keys found!");
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)toRecipientsWithLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy:(LibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy *)ringSelectionStrategy
                                                                                                                                       withLibComAfterlogicPgpUtilMultiMap:(LibComAfterlogicPgpUtilMultiMap *)keys {
  if ([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(keys)) isEmpty]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient map MUST NOT be empty.");
  }
  LibComAfterlogicPgpUtilMultiMap *acceptedKeyRings = [((LibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy *) nil_chk(ringSelectionStrategy)) selectKeyRingsFromCollectionsWithLibComAfterlogicPgpUtilMultiMap:keys];
  for (id __strong identifier in nil_chk([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(acceptedKeyRings)) keySet])) {
    id<JavaUtilSet> acceptedSet = [acceptedKeyRings getWithId:identifier];
    for (LibOrgBouncycastleOpenpgpPGPPublicKeyRing * __strong ring in nil_chk(acceptedSet)) {
      for (LibOrgBouncycastleOpenpgpPGPPublicKey * __strong k in nil_chk(ring)) {
        if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:k]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:k];
        }
      }
    }
  }
  if ([((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) isEmpty]) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"No valid encryption keys found!");
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith>)doNotEncrypt {
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x81, 0, 1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x81, 0, 2, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x81, 0, 3, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x1, 0, 4, -1, 5, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:);
  methods[1].selector = @selector(toRecipients);
  methods[2].selector = @selector(toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyArray:);
  methods[3].selector = @selector(toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingArray:);
  methods[4].selector = @selector(toRecipientsWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollectionArray:);
  methods[5].selector = @selector(toRecipientsWithLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy:withLibComAfterlogicPgpUtilMultiMap:);
  methods[6].selector = @selector(doNotEncrypt);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toRecipients", "[LLibOrgBouncycastleOpenpgpPGPPublicKey;", "[LLibOrgBouncycastleOpenpgpPGPPublicKeyRing;", "[LLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection;", "LLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy;LLibComAfterlogicPgpUtilMultiMap;", "<O:Ljava/lang/Object;>(Llib/com/afterlogic/pgp/key/selection/keyring/PublicKeyRingSelectionStrategy<TO;>;Llib/com/afterlogic/pgp/util/MultiMap<TO;Llib/org/bouncycastle/openpgp/PGPPublicKeyRingCollection;>;)Llib/com/afterlogic/pgp/encryption_signing/EncryptionBuilderInterface$WithAlgorithms;", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl = { "ToRecipientsImpl", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x0, 7, 1, 6, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl;
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl *self, LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  self->this$0_ = outer$;
  NSObject_init(self);
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl *new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl *create_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ToRecipientsImpl)

@implementation LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl

- (instancetype)initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *)outer$ {
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(self, outer$);
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyArray:(IOSObjectArray *)keys {
  if (((IOSObjectArray *) nil_chk(keys))->size_ == 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPPublicKey * const *b__ = a__->buffer_;
    LibOrgBouncycastleOpenpgpPGPPublicKey * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPPublicKey *k = *b__++;
      if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:k]) {
        [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:k];
      }
      else {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J$", @"Key ", [((LibOrgBouncycastleOpenpgpPGPPublicKey *) nil_chk(k)) getKeyID], @" is not a valid encryption key."));
      }
    }
  }
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingArray:(IOSObjectArray *)keys {
  if (((IOSObjectArray *) nil_chk(keys))->size_ == 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRing * const *b__ = a__->buffer_;
    LibOrgBouncycastleOpenpgpPGPPublicKeyRing * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPPublicKeyRing *ring = *b__++;
      for (id<JavaUtilIterator> i = [((LibOrgBouncycastleOpenpgpPGPPublicKeyRing *) nil_chk(ring)) getPublicKeys]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
        LibOrgBouncycastleOpenpgpPGPPublicKey *key = [i next];
        if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:key]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:key];
        }
      }
    }
  }
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection:(LibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection *)keys {
  for (LibOrgBouncycastleOpenpgpPGPPublicKeyRing * __strong ring in nil_chk(keys)) {
    for (id<JavaUtilIterator> i = [((LibOrgBouncycastleOpenpgpPGPPublicKeyRing *) nil_chk(ring)) getPublicKeys]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
      LibOrgBouncycastleOpenpgpPGPPublicKey *key = [i next];
      if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:key]) {
        [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:key];
      }
    }
  }
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms>)andToSelfWithLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy:(LibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy *)ringSelectionStrategy
                                                                                                                                    withLibComAfterlogicPgpUtilMultiMap:(LibComAfterlogicPgpUtilMultiMap *)keys {
  if ([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(keys)) isEmpty]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  LibComAfterlogicPgpUtilMultiMap *acceptedKeyRings = [((LibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy *) nil_chk(ringSelectionStrategy)) selectKeyRingsFromCollectionsWithLibComAfterlogicPgpUtilMultiMap:keys];
  for (id __strong identifier in nil_chk([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(acceptedKeyRings)) keySet])) {
    id<JavaUtilSet> acceptedSet = [acceptedKeyRings getWithId:identifier];
    for (LibOrgBouncycastleOpenpgpPGPPublicKeyRing * __strong k in nil_chk(acceptedSet)) {
      for (id<JavaUtilIterator> i = [((LibOrgBouncycastleOpenpgpPGPPublicKeyRing *) nil_chk(k)) getPublicKeys]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
        LibOrgBouncycastleOpenpgpPGPPublicKey *key = [i next];
        if ([((LibComAfterlogicPgpKeySelectionKeyPublicKeySelectionStrategy *) nil_chk([this$0_ encryptionKeySelector])) acceptWithId:nil withId:key]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->encryptionKeys_)) addWithId:key];
        }
      }
    }
  }
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith>)usingAlgorithmsWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm *)symmetricKeyAlgorithm
                                                                                                   withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil *)hashAlgorithmUtil
                                                                                                withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:(LibComAfterlogicPgpAlgorithmCompressionAlgorithm *)compressionAlgorithm {
  this$0_->symmetricKeyAlgorithm_ = symmetricKeyAlgorithm;
  this$0_->hashAlgorithmUtil_ = hashAlgorithmUtil;
  this$0_->compressionAlgorithm_ = compressionAlgorithm;
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith>)usingSecureAlgorithms {
  this$0_->symmetricKeyAlgorithm_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm, AES_256);
  this$0_->hashAlgorithmUtil_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmHashAlgorithmUtil, SHA512);
  this$0_->compressionAlgorithm_ = JreLoadEnum(LibComAfterlogicPgpAlgorithmCompressionAlgorithm, UNCOMPRESSED);
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x81, 0, 1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x81, 0, 2, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x1, 0, 3, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_WithAlgorithms;", 0x1, 0, 4, -1, 5, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith;", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_SignWith;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:);
  methods[1].selector = @selector(andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyArray:);
  methods[2].selector = @selector(andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingArray:);
  methods[3].selector = @selector(andToSelfWithLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection:);
  methods[4].selector = @selector(andToSelfWithLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy:withLibComAfterlogicPgpUtilMultiMap:);
  methods[5].selector = @selector(usingAlgorithmsWithLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm:withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil:withLibComAfterlogicPgpAlgorithmCompressionAlgorithm:);
  methods[6].selector = @selector(usingSecureAlgorithms);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "andToSelf", "[LLibOrgBouncycastleOpenpgpPGPPublicKey;", "[LLibOrgBouncycastleOpenpgpPGPPublicKeyRing;", "LLibOrgBouncycastleOpenpgpPGPPublicKeyRingCollection;", "LLibComAfterlogicPgpKeySelectionKeyringPublicKeyRingSelectionStrategy;LLibComAfterlogicPgpUtilMultiMap;", "<O:Ljava/lang/Object;>(Llib/com/afterlogic/pgp/key/selection/keyring/PublicKeyRingSelectionStrategy<TO;>;Llib/com/afterlogic/pgp/util/MultiMap<TO;Llib/org/bouncycastle/openpgp/PGPPublicKeyRingCollection;>;)Llib/com/afterlogic/pgp/encryption_signing/EncryptionBuilderInterface$WithAlgorithms;", "usingAlgorithms", "LLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm;LLibComAfterlogicPgpAlgorithmHashAlgorithmUtil;LLibComAfterlogicPgpAlgorithmCompressionAlgorithm;", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl = { "WithAlgorithmsImpl", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x0, 7, 1, 8, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl;
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl *self, LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  self->this$0_ = outer$;
  NSObject_init(self);
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl *new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl *create_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_WithAlgorithmsImpl)

@implementation LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl

- (instancetype)initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *)outer$ {
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(self, outer$);
  return self;
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor>)signWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                                                                 withLibOrgBouncycastleOpenpgpPGPSecretKeyArray:(IOSObjectArray *)keys {
  if (((IOSObjectArray *) nil_chk(keys))->size_ == 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPSecretKey * const *b__ = a__->buffer_;
    LibOrgBouncycastleOpenpgpPGPSecretKey * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPSecretKey *s = *b__++;
      if ([((LibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy *) nil_chk([this$0_ signingKeySelector])) acceptWithId:nil withId:s]) {
        [((id<JavaUtilSet>) nil_chk(this$0_->signingKeys_)) addWithId:s];
      }
      else {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J$", @"Key ", [((LibOrgBouncycastleOpenpgpPGPSecretKey *) nil_chk(s)) getKeyID], @" is not a valid signing key."));
      }
    }
  }
  this$0_->signingKeysDecryptor_ = decryptor;
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor>)signWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                                                             withLibOrgBouncycastleOpenpgpPGPSecretKeyRingArray:(IOSObjectArray *)keys {
  if (((IOSObjectArray *) nil_chk(keys))->size_ == 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  {
    IOSObjectArray *a__ = keys;
    LibOrgBouncycastleOpenpgpPGPSecretKeyRing * const *b__ = a__->buffer_;
    LibOrgBouncycastleOpenpgpPGPSecretKeyRing * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      LibOrgBouncycastleOpenpgpPGPSecretKeyRing *key = *b__++;
      for (id<JavaUtilIterator> i = [((LibOrgBouncycastleOpenpgpPGPSecretKeyRing *) nil_chk(key)) getSecretKeys]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
        LibOrgBouncycastleOpenpgpPGPSecretKey *s = [i next];
        if ([((LibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy *) nil_chk([this$0_ signingKeySelector])) acceptWithId:nil withId:s]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->signingKeys_)) addWithId:s];
        }
      }
    }
  }
  this$0_->signingKeysDecryptor_ = decryptor;
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor>)signWithWithLibComAfterlogicPgpKeySelectionKeyringSecretKeyRingSelectionStrategy:(LibComAfterlogicPgpKeySelectionKeyringSecretKeyRingSelectionStrategy *)ringSelectionStrategy
                                                                                                   withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:(id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>)decryptor
                                                                                                                          withLibComAfterlogicPgpUtilMultiMap:(LibComAfterlogicPgpUtilMultiMap *)keys {
  if ([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(keys)) isEmpty]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Recipient list MUST NOT be empty.");
  }
  LibComAfterlogicPgpUtilMultiMap *acceptedKeyRings = [((LibComAfterlogicPgpKeySelectionKeyringSecretKeyRingSelectionStrategy *) nil_chk(ringSelectionStrategy)) selectKeyRingsFromCollectionsWithLibComAfterlogicPgpUtilMultiMap:keys];
  for (id __strong identifier in nil_chk([((LibComAfterlogicPgpUtilMultiMap *) nil_chk(acceptedKeyRings)) keySet])) {
    id<JavaUtilSet> acceptedSet = [acceptedKeyRings getWithId:identifier];
    for (LibOrgBouncycastleOpenpgpPGPSecretKeyRing * __strong k in nil_chk(acceptedSet)) {
      for (id<JavaUtilIterator> i = [((LibOrgBouncycastleOpenpgpPGPSecretKeyRing *) nil_chk(k)) getSecretKeys]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
        LibOrgBouncycastleOpenpgpPGPSecretKey *s = [i next];
        if ([((LibComAfterlogicPgpKeySelectionKeySecretKeySelectionStrategy *) nil_chk([this$0_ signingKeySelector])) acceptWithId:nil withId:s]) {
          [((id<JavaUtilSet>) nil_chk(this$0_->signingKeys_)) addWithId:s];
        }
      }
    }
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

- (id<LibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor>)doNotSign {
  return new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(this$0_);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor;", 0x81, 0, 1, -1, 2, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor;", 0x81, 0, 3, -1, 4, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor;", 0x1, 0, 5, -1, 6, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionBuilderInterface_Armor;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:);
  methods[1].selector = @selector(signWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:withLibOrgBouncycastleOpenpgpPGPSecretKeyArray:);
  methods[2].selector = @selector(signWithWithLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:withLibOrgBouncycastleOpenpgpPGPSecretKeyRingArray:);
  methods[3].selector = @selector(signWithWithLibComAfterlogicPgpKeySelectionKeyringSecretKeyRingSelectionStrategy:withLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector:withLibComAfterlogicPgpUtilMultiMap:);
  methods[4].selector = @selector(doNotSign);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "signWith", "LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;[LLibOrgBouncycastleOpenpgpPGPSecretKey;", "<O:Ljava/lang/Object;>(Llib/com/afterlogic/pgp/key/protection/SecretKeyRingProtector;[Llib/org/bouncycastle/openpgp/PGPSecretKey;)Llib/com/afterlogic/pgp/encryption_signing/EncryptionBuilderInterface$Armor;", "LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;[LLibOrgBouncycastleOpenpgpPGPSecretKeyRing;", "<O:Ljava/lang/Object;>(Llib/com/afterlogic/pgp/key/protection/SecretKeyRingProtector;[Llib/org/bouncycastle/openpgp/PGPSecretKeyRing;)Llib/com/afterlogic/pgp/encryption_signing/EncryptionBuilderInterface$Armor;", "LLibComAfterlogicPgpKeySelectionKeyringSecretKeyRingSelectionStrategy;LLibComAfterlogicPgpKeyProtectionSecretKeyRingProtector;LLibComAfterlogicPgpUtilMultiMap;", "<O:Ljava/lang/Object;>(Llib/com/afterlogic/pgp/key/selection/keyring/SecretKeyRingSelectionStrategy<TO;>;Llib/com/afterlogic/pgp/key/protection/SecretKeyRingProtector;Llib/com/afterlogic/pgp/util/MultiMap<TO;Llib/org/bouncycastle/openpgp/PGPSecretKeyRingCollection;>;)Llib/com/afterlogic/pgp/encryption_signing/EncryptionBuilderInterface$Armor;", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl = { "SignWithImpl", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x0, 5, 1, 7, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl;
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl *self, LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  self->this$0_ = outer$;
  NSObject_init(self);
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl *new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl *create_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_SignWithImpl)

@implementation LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl

- (instancetype)initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *)outer$ {
  LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(self, outer$);
  return self;
}

- (LibComAfterlogicPgpEncryption_signingEncryptionStream *)asciiArmor {
  this$0_->asciiArmor_ = true;
  return LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_build(self);
}

- (LibComAfterlogicPgpEncryption_signingEncryptionStream *)noArmor {
  this$0_->asciiArmor_ = false;
  return LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_build(self);
}

- (LibComAfterlogicPgpEncryption_signingEncryptionStream *)build {
  return LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_build(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionStream;", 0x1, -1, -1, 0, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionStream;", 0x1, -1, -1, 0, -1, -1, -1 },
    { NULL, "LLibComAfterlogicPgpEncryption_signingEncryptionStream;", 0x2, -1, -1, 0, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder:);
  methods[1].selector = @selector(asciiArmor);
  methods[2].selector = @selector(noArmor);
  methods[3].selector = @selector(build);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoIOException;LLibOrgBouncycastleOpenpgpPGPException;", "LLibComAfterlogicPgpEncryption_signingEncryptionBuilder;" };
  static const J2ObjcClassInfo _LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl = { "ArmorImpl", "lib.com.afterlogic.pgp.encryption_signing", ptrTable, methods, fields, 7, 0x0, 4, 1, 1, -1, -1, -1, -1 };
  return &_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl;
}

@end

void LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl *self, LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  self->this$0_ = outer$;
  NSObject_init(self);
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl *new_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_NEW_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl *create_LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_(LibComAfterlogicPgpEncryption_signingEncryptionBuilder *outer$) {
  J2OBJC_CREATE_IMPL(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl, initWithLibComAfterlogicPgpEncryption_signingEncryptionBuilder_, outer$)
}

LibComAfterlogicPgpEncryption_signingEncryptionStream *LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl_build(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl *self) {
  id<JavaUtilSet> privateKeys = new_JavaUtilHashSet_init();
  for (LibOrgBouncycastleOpenpgpPGPSecretKey * __strong secretKey in nil_chk(self->this$0_->signingKeys_)) {
    [privateKeys addWithId:[((LibOrgBouncycastleOpenpgpPGPSecretKey *) nil_chk(secretKey)) extractPrivateKeyWithLibOrgBouncycastleOpenpgpOperatorPBESecretKeyDecryptor:[((id<LibComAfterlogicPgpKeyProtectionSecretKeyRingProtector>) nil_chk(self->this$0_->signingKeysDecryptor_)) getDecryptorWithJavaLangLong:JavaLangLong_valueOfWithLong_([secretKey getKeyID])]]];
  }
  return new_LibComAfterlogicPgpEncryption_signingEncryptionStream_initWithJavaIoOutputStream_withJavaUtilSet_withJavaUtilSet_withLibComAfterlogicPgpAlgorithmSymmetricKeyAlgorithm_withLibComAfterlogicPgpAlgorithmHashAlgorithmUtil_withLibComAfterlogicPgpAlgorithmCompressionAlgorithm_withBoolean_(self->this$0_->outputStream_, self->this$0_->encryptionKeys_, privateKeys, self->this$0_->symmetricKeyAlgorithm_, self->this$0_->hashAlgorithmUtil_, self->this$0_->compressionAlgorithm_, self->this$0_->asciiArmor_);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(LibComAfterlogicPgpEncryption_signingEncryptionBuilder_ArmorImpl)
